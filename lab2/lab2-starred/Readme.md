# Лабораторная работа 2 (со звездочкой): Docker Compose

## Цель работы
Научиться создавать Docker Compose файлы, понимать различия между «плохими» и «хорошими» практиками при написании docker-compose.yml, а также освоить принципы сетевой изоляции контейнеров.

## Ход работы

### 1. Создание плохого docker-compose.bad.yml

```yaml
version: '3'
services:
  web:
    image: nginx:latest
    ports:
      - "80:80"
      
  api:
    image: python:latest
    build: ./api
    command: python app.py
    environment:
      - DB_HOST=db
      - DB_PASSWORD=secret123
      
  db:
    image: mysql:latest
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
    volumes:
      - db-data:/var/lib/mysql

volumes:
  db-data:
```

### 2. Создание хорошего docker-compose.yml

```yaml
version: '3.9'
services:
  web:
    image: nginx:1.21.6
    networks:
      - web-network
    ports:
      - "80:80"
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
          
  api:
    image: python:3.9.6
    build: ./api
    command: python app.py
    environment:
      DB_HOST: db
    secrets:
      - db_password
    networks:
      - api-network
    depends_on:
      - db
    deploy:
      resources:
        limits:
          cpus: '0.75'
          memory: 768M
          
  db:
    image: mysql:8.0.27
    networks:
      - db-network
    secrets:
      - db_root_password
    volumes:
      - db-data:/var/lib/mysql
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 1G

secrets:
  db_password:
    file: ./secrets/db_password.txt
  db_root_password:
    file: ./secrets/db_root_password.txt

volumes:
  db-data:

networks:
  web-network:
    driver: bridge
  api-network:
    driver: bridge
  db-network:
    driver: bridge
```

## Описание плохих практик и их исправление

### 1. Использование тега `latest` для образов

**Почему это плохо:**
- Нестабильность: при пересборке проекта могут подтянуться новые версии образов с критическими изменениями или багами
- Непредсказуемость: один и тот же docker-compose файл может работать по-разному в разное время
- Проблемы с откатом: сложно воспроизвести среду, так как неясно, какая именно версия образа использовалась ранее

**Исправление в хорошем файле:**
- Указаны конкретные версии образов: `nginx:1.21.6`, `python:3.9.6`, `mysql:8.0.27`
- Добавлена версия формата `3.9` для поддержки современных функций

**Влияние на результат:**
- Обеспечена стабильность среды: при повторной сборке проекта будут использованы те же версии
- Упрощена отладка и воспроизведение проблем
- Повышена безопасность за счет использования проверенных версий

### 2. Хранение паролей в открытом виде в переменных окружения

**Почему это плохо:**
- Угроза безопасности: переменные окружения видны через команду `ps` и могут быть прочитаны любым пользователем хоста
- Риск утечки при логгировании: многие системы логгирования записывают переменные окружения
- Нарушение принципа минимальных привилегий: пароли доступны всем процессам в контейнере

**Исправление в хорошем файле:**
- Пароли вынесены в секреты (secrets), которые монтируются как файлы в защищенные директории
- Используется механизм секретов Docker: `secrets` с указанием путей к файлам

**Влияние на результат:**
- Повышена безопасность: пароли не хранятся в открытом виде в конфигурации
- Секреты доступны только процессам, которым они явно назначены
- Соответствие best practices по безопасности в Docker

### 3. Отсутствие ограничения ресурсов

**Почему это плохо:**
- Опасность "шумного соседа": один контейнер может использовать все ресурсы хоста, нарушая работу других
- Нестабильность системы: при высокой нагрузке контейнер может привести к падению всей системы
- Сложность планирования: невозможно точно оценить, сколько ресурсов потребуется для развертывания

**Исправление в хорошем файле:**
- Добавлены ограничения ресурсов через секцию `deploy.resources.limits`
- Для каждого сервиса указаны конкретные лимиты CPU и памяти

**Влияние на результат:**
- Обеспечена стабильность работы всех сервисов
- Предотвращено переполнение ресурсов хоста
- Улучшено планирование инфраструктуры за счет четкого понимания потребностей каждого сервиса

![bad-docker-compose](https://github.com/user-attachments/assets/ea82a65d-3330-4248-943f-d84dc5657b83)

![bad-docker-compose2](https://github.com/user-attachments/assets/1778363b-01a8-4978-b596-b5b60f6fc6d5)

## Настройка изоляции сетей

В хорошем docker-compose файле была настроена изоляция контейнеров по сетям:

### Как это было реализовано

1. **Явное определение сетей:**
```yaml
networks:
  web-network:
    driver: bridge
  api-network:
    driver: bridge
  db-network:
    driver: bridge
```

2. **Подключение каждого сервиса только к своей сети:**
```yaml
services:
  web:
    networks:
      - web-network
  api:
    networks:
      - api-network
  db:
    networks:
      - db-network
```

### Как это работает

1. Docker по умолчанию создает одну общую сеть для всех сервисов в compose-файле
2. При явном определении сетей и указании для каждого сервиса своей сети, контейнеры изолируются
3. Контейнеры в разных сетях не могут взаимодействовать друг с другом напрямую, так как не видят друг друга в DNS и не имеют сетевых маршрутов

### Принцип изоляции

- Каждая сеть Docker - это отдельный виртуальный коммутатор (bridge)
- Контейнеры могут общаться только с другими контейнерами в той же сети
- DNS-имена разрешаются только для контейнеров в той же сети
- Для межсетевого взаимодействия требуется явное подключение контейнера к нескольким сетям

### Проверка работы изоляции

1. Запуск контейнеров:
```bash
docker-compose up --build -d
```

2. Проверка сетевых настроек:
```bash
docker inspect docker-compose-lab-web-1 | grep -A 20 "NetworkSettings" | grep -A 30 "Networks"
docker inspect docker-compose-lab-api-1 | grep -A 20 "NetworkSettings" | grep -A 30 "Networks"
docker inspect docker-compose-lab-db-1 | grep -A 20 "NetworkSettings" | grep -A 30 "Networks"
```

3. Проверка подключения между контейнерами:
```bash
docker exec docker-compose-lab-web-1 sh -c "echo > /dev/tcp/api/5000 2>/dev/null && echo 'API is reachable' || echo 'API is not reachable'"
docker exec docker-compose-lab-web-1 sh -c "echo > /dev/tcp/db/3306 2>/dev/null && echo 'DB is reachable' || echo 'DB is not reachable'"
```

### Результат проверки

```
WEB → API: "API is not reachable"
WEB → DB: "DB is not reachable"
```

![good-docker-compose](https://github.com/user-attachments/assets/b8c2656c-f78d-424a-a697-b957541a2faa)


Это подтверждает, что контейнеры полностью изолированы друг от друга по сети, но при этом все сервисы запускаются вместе как единый проект.

## Вывод

В ходе выполнения лабораторной работы со звездочкой были освоены следующие аспекты:

1. Выявлены и исправлены три критические проблемы в docker-compose файле:
   - Использование нестабильных тегов `latest`
   - Небезопасное хранение паролей
   - Отсутствие ограничений ресурсов

2. Реализована сетевая изоляция контейнеров:
   - Контейнеры запускаются вместе как единый проект
   - Контейнеры не видят друг друга по сети
   - Обеспечена дополнительная безопасность за счет разделения на изолированные сети

3. Подтверждена работа изоляции через практические проверки:
   - Анализ сетевых настроек контейнеров
   - Проверка подключения между контейнерами


Такой подход особенно важен в production-средах, где изоляция сервисов является критически важной для обеспечения безопасности и стабильности системы. Даже при использовании хорошего Dockerfile, правильная настройка Docker Compose и сетей играет ключевую роль в создании безопасной и эффективной инфраструктуры.
